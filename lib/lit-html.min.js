const envCachesTemplates=(t=>t()===t())(()=>s=>s``);const templates=new Map;const svgTemplates=new Map;export const html=(strings,...values)=>litTag(strings,values,templates,false);export const svg=(strings,...values)=>litTag(strings,values,svgTemplates,true);function litTag(strings,values,templates,isSvg){const key=envCachesTemplates?strings:strings.join("{{--uniqueness-workaround--}}");let template=templates.get(key);if(template===undefined){template=new Template(strings,isSvg);templates.set(key,template)}return new TemplateResult(template,values)}export class TemplateResult{constructor(template,values){this.template=template;this.values=values}};export function render(result,container,partCallback=defaultPartCallback){let instance=container.__templateInstance;if(instance!==undefined&&instance.template===result.template&&instance._partCallback===partCallback){instance.update(result.values);return}instance=new TemplateInstance(result.template,partCallback);container.__templateInstance=instance;const fragment=instance._clone();instance.update(result.values);let child;while(child=container.lastChild){container.removeChild(child)}container.appendChild(fragment)};const attributeMarker=`{{lit-${Math.random()}}}`;const textRegex=/>[^<]*$/;const hasTagsRegex=/[^<]*/;const textMarkerContent="_-lit-html-_";const textMarker=`\x3c!--${textMarkerContent}--\x3e`;const attrOrTextRegex=new RegExp(`${attributeMarker}|${textMarker}`);const lastAttributeNameRegex=/((?:\w|[.\-_$])+)=(?:[^"']*|(?:["][^"]*)|(?:['][^']*))$/;export class TemplatePart{constructor(type,index,name,rawName,strings){this.type=type;this.index=index;this.name=name;this.rawName=rawName;this.strings=strings}};export class Template{constructor(strings,svg=false){this.parts=[];this.svg=svg;this.element=document.createElement("template");this.element.innerHTML=this._getHtml(strings,svg);const walker=document.createTreeWalker(this.element.content,133,null,false);let index=-1;let partIndex=0;const nodesToRemove=[];let previousNode;let currentNode;while(walker.nextNode()){index++;previousNode=currentNode;const node=currentNode=walker.currentNode;if(node.nodeType===1){if(!node.hasAttributes()){continue}const attributes=node.attributes;const attributesWithParts=Array.prototype.filter.call(attributes,attribute=>attribute.value.split(attrOrTextRegex).length>1);for(let i=0;i<attributesWithParts.length;i++){const stringForPart=strings[partIndex];const attributeNameInPart=stringForPart.match(lastAttributeNameRegex)[1];const attribute=attributes.getNamedItem(attributeNameInPart);const stringsForAttributeValue=attribute.value.split(attrOrTextRegex);this.parts.push(new TemplatePart("attribute",index,attribute.name,attributeNameInPart,stringsForAttributeValue));node.removeAttribute(attribute.name);partIndex+=stringsForAttributeValue.length-1}}else if(node.nodeType===3){const nodeValue=node.nodeValue;const strings=nodeValue.split(attrOrTextRegex);if(strings.length>1){const parent=node.parentNode;const lastIndex=strings.length-1;partIndex+=lastIndex;node.textContent=strings[lastIndex];for(let i=0;i<lastIndex;i++){parent.insertBefore(document.createTextNode(strings[i]),node);this.parts.push(new TemplatePart("node",index++))}}else{const previousSibling=node.previousSibling;const nextSibling=node.nextSibling;if((previousSibling===null||previousSibling.nodeType===1)&&(nextSibling===null||nextSibling.nodeType===1)&&nodeValue.trim()===""){nodesToRemove.push(node);currentNode=previousNode;index--}}}else if(node.nodeType===8&&node.nodeValue===textMarkerContent){const parent=node.parentNode;if(node.previousSibling===null||node.previousSibling!==previousNode){parent.insertBefore(document.createTextNode(""),node)}else{index--}this.parts.push(new TemplatePart("node",index++));nodesToRemove.push(node);if(node.nextSibling===null){parent.insertBefore(document.createTextNode(""),node)}else{index--}currentNode=previousNode;partIndex++}}for(const n of nodesToRemove){n.parentNode.removeChild(n)}}_getHtml(strings,svg){const l=strings.length;const a=[];let isTextBinding=false;for(let i=0;i<l-1;i++){const s=strings[i];a.push(s);isTextBinding=s.match(textRegex)!==null||s.match(hasTagsRegex)!==null&&isTextBinding;a.push(isTextBinding?textMarker:attributeMarker)}a.push(strings[l-1]);const html=a.join("");return svg?`<svg>${html}</svg>`:html}};export const getValue=(part,value)=>{if(value!=null&&value.__litDirective===true){value=value(part)}return value===null?undefined:value};export const directive=f=>{f.__litDirective=true;return f};export class AttributePart{constructor(instance,element,name,strings){this.instance=instance;this.element=element;this.name=name;this.strings=strings;this.size=strings.length-1}setValue(values,startIndex){const strings=this.strings;let text="";for(let i=0;i<strings.length;i++){text+=strings[i];if(i<strings.length-1){const v=getValue(this,values[startIndex+i]);if(v&&(Array.isArray(v)||typeof v!=="string"&&v[Symbol.iterator])){for(const t of v){text+=t}}else{text+=v}}}this.element.setAttribute(this.name,text)}};export class NodePart{constructor(instance,startNode,endNode){this.instance=instance;this.startNode=startNode;this.endNode=endNode;this._previousValue=undefined}setValue(value){value=getValue(this,value);if(value===null||!(typeof value==="object"||typeof value==="function")){if(value===this._previousValue){return}this._setText(value)}else if(value instanceof TemplateResult){this._setTemplateResult(value)}else if(Array.isArray(value)||value[Symbol.iterator]){this._setIterable(value)}else if(value instanceof Node){this._setNode(value)}else if(value.then!==undefined){this._setPromise(value)}else{this._setText(value)}}_insert(node){this.endNode.parentNode.insertBefore(node,this.endNode)}_setNode(value){if(this._previousValue===value){return}this.clear();this._insert(value);this._previousValue=value}_setText(value){const node=this.startNode.nextSibling;if(node===this.endNode.previousSibling&&node.nodeType===Node.TEXT_NODE){node.textContent=value}else{this._setNode(document.createTextNode(value===undefined?"":value))}this._previousValue=value}_setTemplateResult(value){let instance;if(this._previousValue&&this._previousValue.template===value.template){instance=this._previousValue}else{instance=new TemplateInstance(value.template,this.instance._partCallback);this._setNode(instance._clone());this._previousValue=instance}instance.update(value.values)}_setIterable(value){if(!Array.isArray(this._previousValue)){this.clear();this._previousValue=[]}const itemParts=this._previousValue;let partIndex=0;for(const item of value){let itemPart=itemParts[partIndex];if(itemPart===undefined){let itemStart=this.startNode;if(partIndex>0){const previousPart=itemParts[partIndex-1];itemStart=previousPart.endNode=document.createTextNode("");this._insert(itemStart)}itemPart=new NodePart(this.instance,itemStart,this.endNode);itemParts.push(itemPart)}itemPart.setValue(item);partIndex++}if(partIndex===0){this.clear();this._previousValue=undefined}else if(partIndex<itemParts.length){const lastPart=itemParts[partIndex-1];itemParts.length=partIndex;this.clear(lastPart.endNode.previousSibling);lastPart.endNode=this.endNode}}_setPromise(value){value.then(v=>{if(this._previousValue===value){this.setValue(v)}});this._previousValue=value}clear(startNode=this.startNode){let node;while((node=startNode.nextSibling)!==this.endNode){node.parentNode.removeChild(node)}}};export const defaultPartCallback=(instance,templatePart,node)=>{if(templatePart.type==="attribute"){return new AttributePart(instance,node,templatePart.name,templatePart.strings)}else if(templatePart.type==="node"){return new NodePart(instance,node,node.nextSibling)}throw new Error(`Unknown part type ${templatePart.type}`)};export class TemplateInstance{constructor(template,partCallback=defaultPartCallback){this._parts=[];this.template=template;this._partCallback=partCallback}update(values){let valueIndex=0;for(const part of this._parts){if(part.size===undefined){part.setValue(values[valueIndex]);valueIndex++}else{part.setValue(values,valueIndex);valueIndex+=part.size}}}_clone(){const fragment=document.importNode(this.template.element.content,true);if(this.template.parts.length>0){const walker=document.createTreeWalker(fragment,133,null,false);const parts=this.template.parts;let index=0;let partIndex=0;let templatePart=parts[0];let node=walker.nextNode();while(node!=null&&partIndex<parts.length){if(index===templatePart.index){this._parts.push(this._partCallback(this,templatePart,node));templatePart=parts[++partIndex]}else{index++;node=walker.nextNode()}}}if(this.template.svg){const svgElement=fragment.firstChild;fragment.removeChild(svgElement);const nodes=svgElement.childNodes;for(let i=0;i<nodes.length;i++){fragment.appendChild(nodes.item(i))}}return fragment}};